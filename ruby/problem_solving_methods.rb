# Release 0: Implement a Simple Search 

# Defined search method that takes array (arr) and integer to find (x).
# Set index to zero.
# Set default variable to nil.
# Call .each method on array; set while loop to run as long as the index of 
# array is equal to the search integer, then the integer assigned to index gets
# returned.
# Set index to count up by 1 each loop.
# If iteration conditions are not met, nil gets returned.

def search_array(arr, x)
  index = 0 
  default = nil
  arr.each do if x == arr[index]
      return index
      # default = index
    end
    index += 1
  end
  return default 
end
  
arr = [42, 89, 23, 1]

p search_array(arr, 1) 
p search_array(arr, 24) 
p search_array(arr, 42)


=begin 
Each new integer in the Fibonacci sequence is generated by adding the previous two integers. 
By starting with 0 and 1, the first 10 terms will be: 0, 1, 2, 3, 5, 8, 13, 21, 34, 55.
Method call 'fib(10)' should return 55; '8' returns 21; '12' should return 144. 
=end 

# Release 1: Calculate Fibonacci Numbers

# Defined method taking argument of number
# The number gets returned if present in range between 0 and 1, as include evaluates
# to true. If false, fib adds the numbers previous by 1 and 2.
# Close method 
# Test by calling method with argument

def fib(n)
    arr = [0, 1]
    fibonacci = ->(arr) {
        if arr.size == n
            arr
        else
            current_number, last_number = arr.last(2)
            fibonacci.(arr + [current_number + last_number])
        end
    }
    fibonacci.(arr)
end
p fib(6)
p fib(100)[-1]

# Driver Code: How to Test Loooooong number: 218922995834555169026
# Add negative index to end of call

# Release 2: Sort an Array

# Bubble Sort 

=begin
'n' represents total number of values in array.
Loop will iterate through entire array & check value for each element
and compare them.
Then it will switch integers if previous integer is greater than next.
'Swapped' checks if item is false.
For (n-1) you want  iterate through one time fewer than the total sum of the array.
'i' represents iterator variable within block parameters - in this case the index.
Simple conditional: if that array element is greater than the next element,
then the elements switch places.
In that case, swapped is true.
'break if not swapped' is syntactic sugar. Then, return array.
Created array, called bubble_sort method with 'a' as argument; printed to irb.
=end 

def bubble_sort(array)
  n = array.length 
  loop do
    swapped = false 
    (n-1).times do |i|
      if array[i] > array[i+1]
        array[i], array[i+1] = array[i+1], array[i]
        swapped = true 
      end
    end
    break if not swapped 
  end 
  array 
end 

a = [1, 4, 3, 2, 5, 4, 6, 3, 7, 8]
p bubble_sort(a)

=begin 
I watched a brief tutorial on YouTube and being able to visualize the concept
was really helpful to understanding it. I didn't feel nervous following along 
and testing my code - on the contrary, I was excited to learn something new with 
the burden of explanation on someone else, for a change.

=end 
